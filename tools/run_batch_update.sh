#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEFAULT_DIRECTORY="$(pwd)"

show_help() {
    cat << EOF
Usage: run_batch_update.sh [DIRECTORY]

Execute SQL batch update files generated by generate_batch_update.py

ARGUMENTS:
    DIRECTORY    Optional directory to scan for batch update files
                 (default: current working directory)

DESCRIPTION:
    Scans for files matching 'batch_update_*.sql' pattern and executes them
    in chronological order using psql. Successfully processed files are moved
    to a 'processed/' subdirectory.

ENVIRONMENT VARIABLES:
    Database connection can be specified using either:
    
    Option 1 - Individual variables:
        PGHOST       PostgreSQL host (default: localhost)
        PGPORT       PostgreSQL port (default: 5432) 
        PGDATABASE   PostgreSQL database name (required)
        PGUSER       PostgreSQL username (required)
        PGPASSWORD   PostgreSQL password (required)
    
    Option 2 - Connection string:
        DATABASE_URL PostgreSQL connection URL
                     Format: postgresql://user:pass@host:port/dbname

EXAMPLES:
    run_batch_update.sh
    run_batch_update.sh /path/to/batch/files
    
    # With environment variables
    PGDATABASE=mydb PGUSER=user PGPASSWORD=pass run_batch_update.sh
    
    # With DATABASE_URL
    DATABASE_URL=postgresql://user:pass@localhost:5432/mydb run_batch_update.sh

EOF
}

parse_arguments() {
    local directory="$DEFAULT_DIRECTORY"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                echo "Use -h or --help for usage information" >&2
                exit 1
                ;;
            *)
                directory="$1"
                break
                ;;
        esac
        shift
    done
    
    if [[ ! -d "$directory" ]]; then
        echo "Error: Directory does not exist: $directory" >&2
        exit 1
    fi
    
    echo "$directory"
}

discover_sql_files() {
    local directory="$1"
    local -a sql_files=()
    
    # Find all files matching batch_update_*.sql pattern
    while IFS= read -r -d '' file; do
        sql_files+=("$file")
    done < <(find "$directory" -maxdepth 1 -name "batch_update_*.sql" -type f -print0 2>/dev/null)
    
    if [[ ${#sql_files[@]} -eq 0 ]]; then
        echo "No SQL batch files found matching pattern: batch_update_*.sql" >&2
        return 1
    fi
    
    # Sort files by timestamp (embedded in filename: batch_update_YYYYMMDD_HHMMSS.sql)
    # This processes oldest files first
    IFS=$'\n' sql_files=($(sort <<<"${sql_files[*]}"))
    
    echo "Found ${#sql_files[@]} SQL batch file(s):" >&2
    for file in "${sql_files[@]}"; do
        local basename_file
        basename_file=$(basename "$file")
        local file_size
        file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "unknown")
        echo "  - $basename_file ($file_size bytes)" >&2
    done
    echo >&2
    
    # Return the sorted array by printing it to stdout
    printf '%s\n' "${sql_files[@]}"
    return 0
}

validate_database_connection() {
    if [[ -z "${DATABASE_URL:-}" ]]; then
        echo "Error: DATABASE_URL environment variable is required" >&2
        echo "Set it to a PostgreSQL connection URL:" >&2
        echo "  export DATABASE_URL=postgresql://user:pass@host:port/dbname" >&2
        return 1
    fi
    
    # Test database connectivity without password prompt
    echo "Testing database connectivity..."
    if ! psql "$DATABASE_URL" --no-password -c "SELECT 1" >/dev/null 2>&1; then
        echo "Error: Failed to connect to database" >&2
        echo "Please verify your DATABASE_URL is correct and the database is accessible" >&2
        echo "DATABASE_URL format: postgresql://user:pass@host:port/dbname" >&2
        return 1
    fi
    
    echo "Database connection successful ✓"
    return 0
}

main() {
    local scan_directory
    scan_directory=$(parse_arguments "$@")
    
    echo "Batch SQL Executor - Scanning directory: $scan_directory"
    echo "Script will execute SQL files matching pattern: batch_update_*.sql"
    echo
    
    # Validate database connection before proceeding
    if ! validate_database_connection; then
        exit 1
    fi
    echo
    
    local -a sql_files
    local discovery_output
    if ! discovery_output=$(discover_sql_files "$scan_directory"); then
        exit 1
    fi
    
    # Read the discovered files into array (compatible with older bash versions)
    while IFS= read -r line; do
        [[ -n "$line" ]] && sql_files+=("$line")
    done <<< "$discovery_output"
    
    echo "Ready to process ${#sql_files[@]} file(s) in chronological order."
    
    # Execute SQL files and track results
    local processed_count=0
    local failed_count=0
    
    for sql_file in "${sql_files[@]}"; do
        if execute_sql_file "$sql_file" "$scan_directory"; then
            ((processed_count++))
        else
            ((failed_count++))
        fi
    done
    
    echo
    echo "=== EXECUTION SUMMARY ==="
    echo "Files processed successfully: $processed_count"
    echo "Files failed: $failed_count"
    echo "Total files: ${#sql_files[@]}"
    
    if [[ $failed_count -gt 0 ]]; then
        echo "Failed files left in place for manual review."
        exit 1
    else
        echo "All files processed successfully!"
        exit 0
    fi
}

execute_sql_file() {
    local sql_file="$1"
    local base_directory="$2"
    local basename_file
    basename_file=$(basename "$sql_file")
    
    echo "Executing: $basename_file"
    
    # Check if corresponding CSV file exists
    local csv_file="${sql_file%.sql}.csv"
    if [[ ! -f "$csv_file" ]]; then
        echo "  ERROR: Required CSV file not found: $(basename "$csv_file")" >&2
        return 1
    fi
    
    # Execute SQL file
    local start_time
    start_time=$(date +%s)
    
    if psql "$DATABASE_URL" --no-password -f "$sql_file"; then
        local end_time
        end_time=$(date +%s)
        local duration=$((end_time - start_time))
        
        echo "  ✓ Completed successfully (${duration}s)"
        
        # Move processed files to processed/ subdirectory
        create_processed_directory "$base_directory"
        move_processed_files "$sql_file" "$csv_file" "$base_directory"
        
        return 0
    else
        echo "  ✗ Execution failed" >&2
        return 1
    fi
}

create_processed_directory() {
    local base_directory="$1"
    local processed_dir="$base_directory/processed"
    
    if [[ ! -d "$processed_dir" ]]; then
        mkdir -p "$processed_dir" || {
            echo "Error: Failed to create processed directory: $processed_dir" >&2
            return 1
        }
    fi
}

move_processed_files() {
    local sql_file="$1"
    local csv_file="$2"
    local base_directory="$3"
    local processed_dir="$base_directory/processed"
    
    # Move SQL file
    if ! mv "$sql_file" "$processed_dir/"; then
        echo "  Warning: Failed to move SQL file to processed directory" >&2
    fi
    
    # Move CSV file
    if ! mv "$csv_file" "$processed_dir/"; then
        echo "  Warning: Failed to move CSV file to processed directory" >&2
    fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
