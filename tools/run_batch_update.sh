#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEFAULT_DIRECTORY="$(pwd)"

show_help() {
    cat << EOF
Usage: run_batch_update.sh [DIRECTORY]

Execute SQL batch update files generated by generate_batch_update.py

ARGUMENTS:
    DIRECTORY    Optional directory to scan for batch update files
                 (default: current working directory)

DESCRIPTION:
    Scans for files matching 'batch_update_*.sql' pattern and executes them
    in chronological order using psql. Successfully processed files are moved
    to a 'processed/' subdirectory.

ENVIRONMENT VARIABLES:
    Database connection can be specified using either:
    
    Option 1 - Individual variables:
        PGHOST       PostgreSQL host (default: localhost)
        PGPORT       PostgreSQL port (default: 5432) 
        PGDATABASE   PostgreSQL database name (required)
        PGUSER       PostgreSQL username (required)
        PGPASSWORD   PostgreSQL password (required)
    
    Option 2 - Connection string:
        DATABASE_URL PostgreSQL connection URL
                     Format: postgresql://user:pass@host:port/dbname

EXAMPLES:
    run_batch_update.sh
    run_batch_update.sh /path/to/batch/files
    
    # With environment variables
    PGDATABASE=mydb PGUSER=user PGPASSWORD=pass run_batch_update.sh
    
    # With DATABASE_URL
    DATABASE_URL=postgresql://user:pass@localhost:5432/mydb run_batch_update.sh

EOF
}

parse_arguments() {
    local directory="$DEFAULT_DIRECTORY"
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                echo "Use -h or --help for usage information" >&2
                exit 1
                ;;
            *)
                directory="$1"
                break
                ;;
        esac
        shift
    done
    
    if [[ ! -d "$directory" ]]; then
        echo "Error: Directory does not exist: $directory" >&2
        exit 1
    fi
    
    echo "$directory"
}

discover_sql_files() {
    local directory="$1"
    local -a sql_files=()
    
    # Find all files matching batch_update_*.sql pattern
    while IFS= read -r -d '' file; do
        sql_files+=("$file")
    done < <(find "$directory" -maxdepth 1 -name "batch_update_*.sql" -type f -print0 2>/dev/null)
    
    if [[ ${#sql_files[@]} -eq 0 ]]; then
        echo "No SQL batch files found matching pattern: batch_update_*.sql" >&2
        return 1
    fi
    
    # Sort files by timestamp (embedded in filename: batch_update_YYYYMMDD_HHMMSS.sql)
    # This processes oldest files first
    IFS=$'\n' sql_files=($(sort <<<"${sql_files[*]}"))
    
    echo "Found ${#sql_files[@]} SQL batch file(s):" >&2
    for file in "${sql_files[@]}"; do
        local basename_file
        basename_file=$(basename "$file")
        local file_size
        file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo "unknown")
        echo "  - $basename_file ($file_size bytes)" >&2
    done
    echo >&2
    
    # Return the sorted array by printing it to stdout
    printf '%s\n' "${sql_files[@]}"
    return 0
}

validate_database_connection() {
    if [[ -z "${DATABASE_URL:-}" ]]; then
        echo "Error: DATABASE_URL environment variable is required" >&2
        echo "Set it to a PostgreSQL connection URL:" >&2
        echo "  export DATABASE_URL=postgresql://user:pass@host:port/dbname" >&2
        return 1
    fi
    
    # Test database connectivity without password prompt
    echo "Testing database connectivity..."
    if ! psql "$DATABASE_URL" --no-password -c "SELECT 1" >/dev/null 2>&1; then
        echo "Error: Failed to connect to database" >&2
        echo "Please verify your DATABASE_URL is correct and the database is accessible" >&2
        echo "DATABASE_URL format: postgresql://user:pass@host:port/dbname" >&2
        return 1
    fi
    
    echo "Database connection successful âœ“"
    return 0
}

main() {
    local scan_directory
    scan_directory=$(parse_arguments "$@")
    
    echo "Batch SQL Executor - Scanning directory: $scan_directory"
    echo "Script will execute SQL files matching pattern: batch_update_*.sql"
    echo
    
    # Validate database connection before proceeding
    if ! validate_database_connection; then
        exit 1
    fi
    echo
    
    local -a sql_files
    local discovery_output
    if ! discovery_output=$(discover_sql_files "$scan_directory"); then
        exit 1
    fi
    
    # Read the discovered files into array (compatible with older bash versions)
    while IFS= read -r line; do
        [[ -n "$line" ]] && sql_files+=("$line")
    done <<< "$discovery_output"
    
    echo "Ready to process ${#sql_files[@]} file(s) in chronological order."
    echo "Implementation of database execution in progress..."
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
